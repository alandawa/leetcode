153. Find Minimum in Rotated Sorted Array
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:
假設一個長度為 n 的陣列按升序排序，在 1 到 n 次之間旋轉。例如，陣列 nums = [0,1,2,4,5,6,7] 可能變為：

[4,5,6,7,0,1,2] if it was rotated 4 times.
[4,5,6,7,0,1,2] 如果旋轉 4 次。
[0,1,2,4,5,6,7] if it was rotated 7 times.
[0,1,2,4,5,6,7] 如果旋轉 7 次。
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
請注意，旋轉陣列 [a[0]， a[1]， a[2]， ...， a[n-1]] 1 次會導致數位 [a[n-1]， a[0]， a[1]， a[2]， ...， a[n-2]]。

Given the sorted rotated array nums of unique elements, return the minimum element of this array.
給定唯一元素的排序旋轉數位數，返回此陣列的最小元素。

You must write an algorithm that runs in O(log n) time.
您必須編寫一個在 O（log n） 時間內運行的演算法

-----------------------------------------------------------------------------------
class Solution {
    public int findMin(int[] nums) {
        int min=Integer.MAX_VALUE;
        for(int num :nums){
            if(num<min){
                min=num;
            }
        }


        return min;
    }
}