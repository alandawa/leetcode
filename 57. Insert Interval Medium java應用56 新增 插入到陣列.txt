57. Insert Interval 
57. 插入間隔
You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
您將得到一個不重疊間隔間隔的陣列，其中 intervals[i] = [starti， endi] 表示第 i 個間隔的開始和結束，並且間隔按開始i 的升序排序。您還會獲得一個間隔 newInterval = [start， end]，它表示另一個間隔的開始和結束。

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
將 newInterval 插入到間隔中，以便間隔仍按開始i 的升序排序，並且間隔仍然沒有任何重疊間隔（如有必要，請合併重疊間隔）。

Return intervals after the insertion.
插入後的返回間隔。

Note that you don't need to modify intervals in-place. You can make a new array and return it.
請注意，您無需就地修改間隔。您可以建立新陣列並返回它。





--------------------------------------------------
import java.util.*;
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
          // 要插入的位置
        int insertIndex = 0;

        // 插入操作
        intervals = insertInto2DArray(intervals, newInterval, insertIndex);


        return merge(intervals);

    }


    public int[][] merge(int[][] intervals) {
        if (intervals.length == 0) return new int[0][0];
        
        // 根据起始值对区间进行排序
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        // 初始化一个列表来存储合并后的区间
        List<int[]> merged = new ArrayList<>();
        
        // 从第一个区间开始
        int[] currentInterval = intervals[0];
        merged.add(currentInterval);
        
        // 遍历区间
        for (int i = 1; i < intervals.length; i++) {
            int[] interval = intervals[i];
            
            // 如果当前区间与合并列表中的最后一个区间重叠
            if (interval[0] <= currentInterval[1]) {
                // 通过更新结束值来合并它们
                currentInterval[1] = Math.max(currentInterval[1], interval[1]);
            } else {
                // 否则，将新区间添加到合并列表中
                currentInterval = interval;
                merged.add(currentInterval);
            }
        }
        
        // 将列表转换为二维数组
        return merged.toArray(new int[merged.size()][]);
    }

     public static int[][] insertInto2DArray(int[][] original, int[] newElement, int index) {
        // 檢查插入位置是否有效
        if (index < 0 || index > original.length) {
            throw new IllegalArgumentException("Invalid index for insertion.");
        }

        // 創建新的二維數組，比原數組多一行
        int[][] result = new int[original.length + 1][];

        // 將原數組的內容複製到新數組中
        for (int i = 0; i < original.length + 1; i++) {
            if (i < index) {
                result[i] = original[i];
            } else if (i == index) {
                result[i] = newElement;
            } else {
                result[i] = original[i - 1];
            }
        }

        return result;
    }
}