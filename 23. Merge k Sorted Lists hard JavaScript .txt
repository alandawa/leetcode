根据你给出的 JavaScript 函数定义，这是一个用于合并多个有序链表的函数 `mergeKLists`。这里我会为你补充完整这个函数的实现，同时添加中文注释以便理解每个步骤的作用和逻辑。

```javascript
/**
 * 合併多個有序鏈表
 * @param {ListNode[]} lists - 有序鏈表數組
 * @return {ListNode} - 合併後的有序鏈表頭節點
 */
var mergeKLists = function(lists) {
    // 檢查輸入的 lists 是否為空或者長度為0，如果是，返回null
    if (!lists || lists.length === 0) {
        return null;
    }
    
    // 調用 mergeLists 函數合併 lists 數組中的所有鏈表
    return mergeLists(lists, 0, lists.length - 1);
};

/**
 * 合併 lists 數組中指定區間的有序鏈表
 * @param {ListNode[]} lists - 有序鏈表數組
 * @param {number} left - 左邊界索引
 * @param {number} right - 右邊界索引
 * @return {ListNode} - 合併後的有序鏈表頭節點
 */
function mergeLists(lists, left, right) {
    // 如果 left 等於 right，表示只有一個鏈表，直接返回該鏈表
    if (left === right) {
        return lists[left];
    }
    
    // 計算中間索引
    var mid = left + Math.floor((right - left) / 2);
    
    // 遞歸合併左半部分和右半部分的鏈表
    var l1 = mergeLists(lists, left, mid);
    var l2 = mergeLists(lists, mid + 1, right);
    
    // 合併兩個已排序的鏈表
    return mergeTwoLists(l1, l2);
}

/**
 * 合併兩個有序鏈表
 * @param {ListNode} l1 - 第一個有序鏈表的頭節點
 * @param {ListNode} l2 - 第二個有序鏈表的頭節點
 * @return {ListNode} - 合併後的有序鏈表頭節點
 */
function mergeTwoLists(l1, l2) {
    // 創建虛擬頭節點
    var dummy = new ListNode(-1);
    var current = dummy;
    
    // 遍歷兩個鏈表，將小的節點接入到合併後的鏈表中
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    // 將剩餘部分接入到合併後的鏈表中
    if (l1) {
        current.next = l1;
    }
    
    if (l2) {
        current.next = l2;
    }
    
    // 返回虛擬頭節點的下一個節點，即合併後的有序鏈表的頭節點
    return dummy.next;
}
```

### 解释：

1. **mergeKLists 函数**：
   - 这是主函数，接收一个 ListNode 数组 `lists`，其中每个元素都是一个有序链表的头节点。
   - 首先检查输入的 lists 是否为空或者长度为0，如果是，直接返回 null。
   - 调用 `mergeLists(lists, 0, lists.length - 1)` 函数，将整个数组的链表进行合并排序。

2. **mergeLists 函数**：
   - 这是一个递归函数，用于合并 `lists` 数组中指定区间 `[left, right]` 的有序链表。
   - 如果 `left === right`，表示只有一个链表，直接返回该链表。
   - 否则，计算中间索引 `mid`，分别递归合并左半部分和右半部分的链表，然后调用 `mergeTwoLists` 函数合并这两个已排序的子链表。

3. **mergeTwoLists 函数**：
   - 这个函数用于合并两个有序链表 `l1` 和 `l2`。
   - 创建一个虚拟头节点 `dummy`，以及一个指针 `current` 用于构建合并后的链表。
   - 遍历 `l1` 和 `l2`，将较小的节点接入到 `current.next`，并将 `current` 指针后移。
   - 最后，将剩余部分直接接入到 `current.next`。
   - 返回 `dummy.next`，即合并后的有序链表的头节点。

这样的实现使用了分治法的思想，将问题拆分为较小的子问题并递归解决，最终将多个有序链表合并成一个有序链表。中文注释可以帮助理解每个函数的作用和实现细节，提升代码的可读性和易理解性。