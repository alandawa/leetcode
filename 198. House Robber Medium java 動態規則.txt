198. House Robber 
198. 入室搶劫

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
你是一個職業劫匪，計劃搶劫沿街的房屋。每棟房子都藏有一定數量的錢，阻止你搶劫每棟房子的唯一限制是相鄰的房子都連接了安全系統，如果兩個相鄰的房子在同一天晚上被闖入，它會自動聯繫員警。

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
給定一個整數陣列 nums ，表示每棟房子的金額，返回您今晚可以在不報警的情況下搶劫的最大金額。
--------------------------------------------------
這個問題實際上是一個典型的動態規劃問題，可以用來解決“打劫房屋”這種類似的問題。你的程式碼目前只處理了間隔為2的情況，實際上應該用一個動態規劃的方法來解決更一般的情況，下面我將給出詳細的解釋和正確的解法。

### 問題描述

你要設計一個解法來最大化在不觸發警報的情況下能夠搶到的金額。每個房子相鄰的房子有警報系統，如果兩個相鄰的房子都被搶劫了，警報系統會被觸發。

### 解法

我們可以使用動態規劃來解決這個問題。設 `dp[i]` 為到第 `i` 間房子的最大搶劫金額。對於每一間房子，我們有兩個選擇：

1. **搶劫第 `i` 間房子**：如果我們選擇搶劫第 `i` 間房子，那麼我們不能搶劫第 `i-1` 間房子，但可以考慮搶劫第 `i-2` 間房子的金額。
2. **不搶劫第 `i` 間房子**：如果我們選擇不搶劫第 `i` 間房子，那麼我們可以考慮第 `i-1` 間房子的最大搶劫金額。

因此，`dp[i]` 的轉移方程式可以寫為：
\[ dp[i] = \max(dp[i-1], dp[i-2] + nums[i]) \]

### 邊界條件

1. 當只有一間房子時，最大金額就是這一間房子的金額。
2. 當有兩間房子時，最大金額是兩者中的較大值。

### 代碼實現

下面是動態規劃的解法：

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        
        // 如果只有一間房子
        if (n == 1) return nums[0];
        
        // 當有兩間房子
        if (n == 2) return Math.max(nums[0], nums[1]);
        
        // 初始化 DP 陣列
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        
        // 填充 DP 陣列
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
        }
        
        // 返回最大值
        return dp[n-1];
    }
}
```

### 解釋

1. **初始化**：`dp[0]` 設為第一間房子的金額，`dp[1]` 設為前兩間房子中較大的一個金額。
2. **動態規劃填充**：對於每一間房子 `i`，我們計算搶劫到第 `i` 間房子的最大金額，並用之前的結果來更新 `dp[i]`。
3. **返回結果**：最後，`dp[n-1]` 是搶劫到最後一間房子的最大金額。

這樣的解法確保了我們在每一步都做出了最佳選擇，並能夠得到全局的最佳解。