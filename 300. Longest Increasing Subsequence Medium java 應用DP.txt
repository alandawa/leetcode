300. Longest Increasing Subsequence
300. 最長的遞增子序列
Given an integer array nums, return the length of the longest strictly increasing
給定一個整數陣列 nums，返回嚴格遞增的最長長度
subsequence 子序列
Example 1: 範例 1：

Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Example 2: 範例 2：

Input: nums = [0,1,0,3,2,3]
Output: 4
Example 3: 範例 3：

Input: nums = [7,7,7,7,7,7,7]
Output: 1

-----------------------------------------------------------
錯誤的
import java.util.Arrays;

class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        
        // 檢查輸入數組是否為空或長度為0
        if (nums == null || n == 0) {
            return 0; // 如果是空數組，沒有利潤可以獲得
        }
        int[] dp=new int[n];
        int min=Integer.MAX_VALUE;
        dp[0]=1;



        for{int i=1 ;i<n;i++}{
            min=Math.min(min,nums[i-1]);
            if(nums[i]>nums[i-1]){
                dp[i]=dp[i-1]+1;
            }else if(nums[i]<=nums[i-1]){
                dp[i]=dp[i-1];

            }
        }


        
        return dp[n];
-----------------------------------------------------------
你提供的 Java 程式碼片段是用來求解「最長遞增子序列」（Longest Increasing Subsequence, LIS）的長度。不過程式碼裡有一些錯誤，我會在這裡解釋程式碼的錯誤，並給出正確的解決方案。

### 原程式碼問題

1. **`for` 迴圈語法錯誤**：
   - 應使用圓括號 `()`，而不是花括號 `{}`。

2. **`min` 變數**：
   - 變數 `min` 在這裡似乎沒有用處，可以去掉。

3. **`dp` 陣列初始化**：
   - 初始值應該設定為 1，因為每個元素至少能夠形成長度為 1 的子序列。

4. **返回值錯誤**：
   - 應返回 `dp` 陣列中的最大值，而不是 `dp[n]`。因為 `dp[n]` 可能超出範圍，正確的應該是 `dp[n-1]` 或 `Arrays.stream(dp).max().getAsInt()`。

### 正確的程式碼

下面是修正後的 Java 程式碼，它可以正確地計算最長遞增子序列的長度：

```java
import java.util.Arrays;

class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        
        // 檢查輸入數組是否為空或長度為0
        if (nums == null || n == 0) {
            return 0; // 如果是空數組，返回0
        }
        
        // dp[i] 代表以 nums[i] 結尾的最長遞增子序列的長度
        int[] dp = new int[n];
        Arrays.fill(dp, 1); // 初始化每個位置的最長遞增子序列長度為1

        // 計算每個位置的最長遞增子序列長度
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        // 返回 dp 陣列中的最大值
        return Arrays.stream(dp).max().getAsInt();
    }
}
```

### 說明

- **`dp` 陣列**：
  - `dp[i]` 表示以 `nums[i]` 結尾的最長遞增子序列的長度。
  
- **外層 `for` 迴圈**：
  - 遍歷每一個元素 `nums[i]`，用來更新 `dp[i]`。

- **內層 `for` 迴圈**：
  - 檢查 `nums[i]` 是否可以擴展以 `nums[j]` 結尾的遞增子序列。如果可以，則更新 `dp[i]` 為 `dp[j] + 1`。

- **返回結果**：
  - 最後返回 `dp` 陣列中的最大值，即為最長遞增子序列的長度。

### 輸入輸出範例

1. **輸入**: `[10,9,2,5,3,7,101,18]`
   **輸出**: `4`（最長遞增子序列為 `[2, 3, 7, 101]`）

2. **輸入**: `[0,1,0,3,2,3]`
   **輸出**: `4`（最長遞增子序列為 `[0, 1, 2, 3]`）

3. **輸入**: `[7,7,7,7,7,7,7]`
   **輸出**: `1`（所有元素相同，最長遞增子序列的長度為 1）

希望這些解釋和程式碼對你有幫助！如果有其他問題或需要更多解釋，隨時告訴我。
----------------------------------------------------------------------------------------

在你提供的程式碼和修正的過程中，`j` 的作用是用來檢查和更新最長遞增子序列的長度。讓我詳細說明 `j` 的目的和它在演算法中的角色。

### `j` 的作用

在最長遞增子序列問題中，我們使用動態規劃來解決問題。為了更新 `dp[i]`，我們需要考慮以 `nums[i]` 結尾的最長遞增子序列是否可以從之前的數字 `nums[j]` 繼續延伸。這樣的檢查需要一個內層迴圈來遍歷 `i` 前面的位置，以確保每個可能的前綴子序列都被考慮到。

### 內層迴圈 `j` 的具體功能

1. **遍歷所有 `i` 前面的元素**：
   - `j` 遍歷從 `0` 到 `i-1` 的所有索引。
   - 這樣可以檢查 `nums[i]` 是否可以延續以 `nums[j]` 結尾的遞增子序列。

2. **更新 `dp[i]`**：
   - 如果 `nums[i]` 大於 `nums[j]`（即可以延續遞增子序列），那麼 `dp[i]` 可以更新為 `dp[j] + 1`。
   - `dp[j] + 1` 表示如果 `nums[i]` 可以跟隨 `nums[j]`，則 `dp[i]` 的長度應比 `dp[j]` 的長度多 1。

### 程式碼中的 `j` 部分

以下是包含 `j` 的程式碼段：

```java
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```

### 步驟說明

1. **外層迴圈 (`i`)**：
   - 遍歷每一個數字 `nums[i]`，`i` 從 `1` 到 `n-1`。
   - 這樣可以考慮所有可能的結尾數字 `nums[i]`。

2. **內層迴圈 (`j`)**：
   - 遍歷所有 `i` 之前的數字 `nums[j]`，`j` 從 `0` 到 `i-1`。
   - 檢查 `nums[i]` 是否大於 `nums[j]`，如果是，則 `nums[i]` 可以跟隨在 `nums[j]` 後面，從而形成一個更長的遞增子序列。

3. **更新 `dp[i]`**：
   - `dp[i]` 更新為 `Math.max(dp[i], dp[j] + 1)`。這意味著如果 `nums[i]` 可以跟隨 `nums[j]`，則 `dp[i]` 可能需要更新為 `dp[j] + 1`。

### 總結

`j` 主要用於幫助找出所有可能的前綴，來確定 `nums[i]` 是否可以形成更長的遞增子序列。這樣的檢查確保了我們能夠正確地計算以每個 `nums[i]` 為結尾的最長遞增子序列的長度。
-----------------------------------------------------------------------------------------------------
要在 \(O(N \log N)\) 的時間複雜度下求解「最長遞增子序列」（LIS）問題，可以使用一種更高效的方法，這種方法基於二分查找。這種方法比起暴力法 \(O(N^2)\) 和基本的動態規劃方法 \(O(N^2)\) 要快得多，但不可能在 \(O(N)\) 時間複雜度下解決。

### \(O(N \log N)\) 的方法

1. **核心思路**：
   - 使用一個輔助的數組來維護當前找到的遞增子序列的可能結尾。
   - 利用二分查找快速插入新元素或更新已有的結尾。

2. **算法步驟**：
   - 遍歷輸入數組的每個元素。
   - 使用二分查找確定這個元素應該插入到輔助數組中的哪個位置，或者更新輔助數組中的某個位置。
   - 輔助數組的長度即為最長遞增子序列的長度。

### 實現細節

以下是實現此算法的 Java 程式碼：

```java
import java.util.Arrays;

class Solution {
    public int lengthOfLIS(int[] nums) {
        // 對於空數組，長度為0
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // dp 數組用來保存當前找到的遞增子序列的結尾元素
        int[] dp = new int[nums.length];
        int length = 0; // 當前遞增子序列的長度

        for (int num : nums) {
            // 使用二分查找找到該元素應該插入的位置
            int left = 0, right = length;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (dp[mid] < num) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            // left 是該元素應插入的位置
            dp[left] = num;
            // 更新長度
            if (left == length) {
                length++;
            }
        }

        return length;
    }
}
```

### 說明

1. **`dp` 陣列**：
   - `dp[i]` 保存的是長度為 `i+1` 的遞增子序列的最後一個元素。
   - 陣列 `dp` 在遍歷過程中保持遞增的順序。

2. **二分查找**：
   - 對 `dp` 陣列使用二分查找來確定新元素的位置或更新位置。這樣可以在對數時間內完成插入或更新操作。

3. **長度更新**：
   - 如果新元素的插入位置等於當前 `length`，這意味著我們找到了更長的遞增子序列，所以 `length` 增加 1。

### 總結

這種 \(O(N \log N)\) 的方法透過二分查找來有效地維護和更新最長遞增子序列的可能結尾，使得整體時間複雜度降低到 \(O(N \log N)\)。這比傳統的 \(O(N^2)\) 方法效率高得多，但無法達到 \(O(N)\) 的複雜度。

