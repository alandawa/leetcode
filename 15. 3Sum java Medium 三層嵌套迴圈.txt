使用三層嵌套迴圈來解決「三數之和」的問題會比較簡單直觀，但同時也會增加時間複雜度，效率較低。以下是使用三層嵌套迴圈的程式碼示例：

```java
import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        
        // 排序數組，方便找出唯一解
        Arrays.sort(nums);
        
        int n = nums.length;
        
        // 使用三層嵌套迴圈來找出所有符合條件的三數組合
        for (int i = 0; i < n - 2; i++) {
            // 避免重複計算相同的第一個數字
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            for (int j = i + 1; j < n - 1; j++) {
                // 避免重複計算相同的第二個數字
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                
                for (int k = j + 1; k < n; k++) {
                    // 避免重複計算相同的第三個數字
                    if (k > j + 1 && nums[k] == nums[k - 1]) {
                        continue;
                    }
                    
                    // 檢查是否找到符合條件的組合
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                        result.add(triplet);
                    }
                }
            }
        }
        
        return result;
    }
}
```

### 解釋程式碼：

1. **排序數組**：
   - 首先將數組排序，這樣可以方便在迴圈中找到唯一的三數組合。

2. **三層嵌套迴圈**：
   - 外層迴圈 `i` 遍歷第一個數字。
   - 中層迴圈 `j` 遍歷第二個數字，並確保 `j > i` 以避免重複計算。
   - 內層迴圈 `k` 遍歷第三個數字，確保 `k > j` 以避免重複計算。
   - 每當找到符合條件的三數組合 `nums[i] + nums[j] + nums[k] == 0` 時，就將其加入到 `result` 中。

3. **重複元素的處理**：
   - 在每層迴圈內，使用條件判斷來跳過重複的數字，以確保不重複計算相同的三數組合。

4. **返回結果**：
   - 最後返回所有找到的符合條件的三數組合的列表 `result`。

### 注意事項：

- **效率問題**：
  - 這種解法的時間複雜度是 O(n^3)，其中 n 是數組的長度。因此，對於較大的數組，這種方法可能效率較低，特別是當 n 很大時。

- **空間問題**：
  - 雖然這種解法的空間複雜度是 O(1)（除了存儲結果的列表之外），但是其時間複雜度的增長可能會限制其實際應用範圍。

雖然這段程式碼相對簡單，但使用了三層嵌套迴圈來實現，這在某些情況下可能會導致效能問題。因此，通常建議使用更有效率的方法，例如雙指針法（Two Pointers Approach），來解決這類問題。